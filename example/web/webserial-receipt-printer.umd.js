!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).WebSerialReceiptPrinter = e() }(this, (function () { "use strict"; class t { constructor(t) { this._events = {} } on(t, e) { this._events[t] = this._events[t] || [], this._events[t].push(e) } emit(t, ...e) { let n = this._events[t]; n && n.forEach((t => { setTimeout((() => t(...e)), 0) })) } } class e { } return class extends e { #t; #e = {}; #n = null; #s = null; #i = []; #r = { running: !1, closing: !1 }; constructor(e) { super(), this.#t = new t, this.#e = Object.assign({ baudRate: 9600, bufferSize: 255, dataBits: 8, flowControl: "none", parity: "none", stopBits: 1 }, e), navigator.serial.addEventListener("disconnect", (t => { this.#n == t.target && this.#t.emit("disconnected") })) } async connect() { try { let t = await navigator.serial.requestPort(); return !!t && (await this.#o(t), !0) } catch (t) { return console.log("Could not connect! " + t), !1 } } async reconnect(t) { if (!t.vendorId || !t.productId) return; let e = (await navigator.serial.getPorts()).filter((e => { let n = e.getInfo(); return n.usbVendorId == t.vendorId && n.usbProductId == t.productId })); 1 == e.length && await this.#o(e[0]) } async#o(t) { try { this.#n = t, this.#r.closing = !1, await this.#n.open(this.#e); let e = this.#n.getInfo(); return this.#t.emit("connected", { type: "serial", vendorId: e.usbVendorId || null, productId: e.usbProductId || null, language: null, codepageMapping: null }), !0 } catch (t) { return console.log("Could not open port! " + t), !1 } } async disconnect() { this.#n && (this.#r.closing = !0, this.#s.cancel(), await this.#s.closed, await this.#n.close(), this.#n = null, this.#t.emit("disconnected")) } async listen() { return this.#a(), !0 } async#a() { for (; this.#n.readable && !1 === this.#r.closing;) { this.#s = this.#n.readable.getReader(); try { for (; ;) { const { value: t, done: e } = await this.#s.read(); if (e) break; t && this.#t.emit("data", t) } } catch (t) { } finally { this.#s.releaseLock() } } } async print(t) { this.#i.push(t), this.run() } async run() { if (this.#r.closing) return; if (this.#r.running) return; this.#r.running = !0; const t = this.#n.writable.getWriter(); let e; for (; e = this.#i.shift();)await t.write(e); t.releaseLock(), this.#r.running = !1 } addEventListener(t, e) { this.#t.on(t, e) } } }));
//# sourceMappingURL=webserial-receipt-printer.umd.js.map
